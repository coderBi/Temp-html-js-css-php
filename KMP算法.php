<?php
/*
KMP算法分析：
	1）KMP算法是用于在一个字符串s1中查询找s2首次出现的位置。
	2）首先传统的O(N*N)算法是，从s1[0]开始与s2进行按位比对，如果出现了从s1[0]开始的子串不能和s2完全匹配，就从s1[1]开始接着匹配。这样一直进行到s1可匹配的子串长度小于s2.
	3)KMP算法优化的部分是如果前一次s1[i]开始的字符串不匹配，那么下一次，并不从s[i+1]开始和s2从头进行新的匹配。KMP算法中采取的方式是s1中位置指针不动，也就是停留在当前的不匹配的位置上，然后假设s2从的位置重置为一个值，这个值保证前面的s2[0]~s2[k-1]与s1中完全匹配。这样省略前面k个元素的比较，直接从s2[k]开始进行比对。由于s1中的位置指针从来没有后移，所以算法的复杂度达到了O(N)
	4）在s1中的位置指针不进行变动的前提下，关键是找到s2中的位置指针在不匹配的时候应该如何重置为一个合适的值。KMP算法给出的方案如下：假设s2为 abbabX，如果匹配到X不匹配，这时候s2中的指针索引走到s2[5]，那么下一次重新开始的匹配位置s2[2]，因为前面的ab已经确定可以匹配到了。这个判断可通过比对X前面的字符串abbab的前缀子串与后缀子串得到，由于前缀子串为bbab而后缀子串为abba，可以看到二者重合的部分是ab，由于数组脚标从0开始，那么s2[2(这个也就是重复的元素个数)]就是下一个s2中检查匹配的索引。通过上面的描述，可以建立一个针对s2中所有元素的的next数组 next[i]表示i脚标不匹配的时候下一个检查匹配的s2索引。
	5）如果对于s2每一个位置，都进行前缀与后缀的比对，这个复杂度是不可接受的。通过下面的观察，可以线性的建立这个next数组。为了查找next[i]，先考虑next[i-1]，假设next[i-1]=k，那么0~k-1是之前的前后缀重复的部分，现在只需要判断s2[next[i-1]]与s2[i-1]是否相等，如果相等，那么next[i] = next[i-1] + 1。如果不相等，此时做一个假想的移动，将s2[i-1]移动到s2[next[i-1]]的位置，那么这个问题变成了在一直next[0]~next[k-1]的情况下，求解next[k]的问题，可以发现这是一个递归的表述。
	6)通过上面的描述，可发现next数组的求解是一个递归思想，那么现在的问题就是找打这个递归的base。可以注意到i=0时，因为s2[0]出现了不匹配，所以下一次匹配的s2的位置索引还是落在0,但是这时s1需要向后移动一位，这是一个特殊情况（因为其他情况s1的匹配位置是不会动的），可以理解为这时next[0]=-1（s2的“-1”脚标元素与s1的当前元素匹配）。由于s2[-1]会越界，所以没有办法直接通过比对s2[next[0]]和s2[0]来计算next[1]，所以，还得单独分析next[1]。s2[1]不匹配的分析前面只有一个s2[0]单独构成的序列，它的前缀与后缀都是0，所以next[1]=0
*/


/*
	KMP算法：在一个字符串中查找某个子串第一次出现的位置
@param string $findIn 要查找的父字符串
@param string $find  要查找的目标子字符串
@return int | false  成功找到了返回第一次找到的目标索引位置  如果没有找到返回false
*/
function KMP($findIn='',$find=''){
	$len1 = strlen($findIn); $len2 = strlen($find);
	//先构建next数组
	$next = array();
	$next[0] = -1;
	$next[1] = 0;
	for($i = 2; $i < $len2; ++$i){
		$k = $next[$i-1];
		//这里用迭代（循环） 因为考虑递归的效率和这里其实递归并不是很好写
		while($k >= 0 && $find[$i-1] != $find[$k])
			$k = $next[$k];
		$next[$i] = $k + 1;
	}

	//在$findIn中查找$find首次出现的位置，如果没有找到返回false
	for($i = 0, $j = 0; $i < $len1 && $j < $len2;){
		if($j == -1 || $findIn[$i] == $find[$j]){
			$i++;
			$j++;
		}else{
			$j = $next[$j];  //这里可能导致$j=-1
		}
	}
	return $i < $len1 ? $i - $len2 : false;
}

//测试
$s1 = "hello world hello";
$s2 = "world";
$s3 = "xxx";
var_dump(KMP($s1,$s2));
var_dump(KMP($s1,$s3));